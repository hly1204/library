---
title: Suffix Array (SA-IS)
documentation_of: ./suffix_array_sais.hpp
---

## 后缀数组

后缀数组即对于串 $S$ 每个字符开头的后缀都进行排序后按顺序在数组中存储后缀开始的索引。

## 诱导排序

在 SA-IS 即诱导排序中我们假设 $S$ 末尾有一个为零的最小字典序的字符。

诱导排序的主旨为我们只需要选择 $S$ 所有后缀这个集合中的一组“恰当”的子集（这个子集为所有 LMS-型后缀），只要子集已经有序，那么就可以在线性时间内“诱导”出所有后缀的相对顺序。

- L-型后缀意为 larger 即其字典序比它右边一个字符开头的后缀大；
- S-型后缀意为 smaller 即其字典序比它右边一个字符开头的后缀小；
- LMS-型后缀本身是 S-型后缀但该后缀的左侧为 L-型后缀，所以 LMS 为 left most S-type 的缩写。

我们注意 LMS-型后缀的定义，其左侧必须为 L-型后缀，这也意味着字符串本身这个后缀如果为 S-型后缀那么其也不属于 LMS-型后缀。

我们将整个后缀数组按照每个后缀的首字母划分为多个“桶”，每个桶中首字母必定相同，更进一步的，在每个桶中 L-型后缀必然排名在 S-型后缀前。

在代码中我们计算每个桶的开头和结尾，放入有序的 LMS-型后缀，从桶的末尾依次放入。后对 L-型后缀进行诱导，从桶的开头依次放入，注意此时 LMS-型后缀也未必在其恰当的位置，我们需要利用 L-型后缀之间的相对顺序对 S-型后缀进行诱导。

证明略。注意我们对 LMS-子串也使用该方法进行排序后重新命名，那么 LMS-后缀间的相对顺序只需要求解这个新的字符串的后缀数组即可，此时问题至少被减少为原先的一半，那么 $T(n)=T(n/2)+O(n)$ 有 $T(n)=O(n)$。

诱导排序的思想由 P. Ko 和 S. Aluru 提出，但是他们对于 LMS-子串的排序使用了更为复杂的另一种方法且需要使用到他们定义的数据结构，而 G. Nong 、 S. Zhang 和 W. H. Chan 则是提出 LMS-子串也可以使用诱导排序。

## 参考文献

- G. Nong, S. Zhang, and W. H. Chan, “Linear suffix array construction by almost pure induced-sorting,” in Proceedings of DCC, U.S.A., Mar. 2009.