---
data:
  _extendedDependsOn: []
  _extendedRequiredBy: []
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: test/convolution/2d_convolution.0.test.cpp
    title: test/convolution/2d_convolution.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/convolution/bitwise_and_convolution.0.test.cpp
    title: test/convolution/bitwise_and_convolution.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/convolution/bitwise_xor_convolution.0.test.cpp
    title: test/convolution/bitwise_xor_convolution.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/convolution/convolution_mod.0.test.cpp
    title: test/convolution/convolution_mod.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/convolution/multidimensional_convolution.0.test.cpp
    title: test/convolution/multidimensional_convolution.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/data_structure/dynamic_sequence_range_affine_range_sum.0.test.cpp
    title: test/data_structure/dynamic_sequence_range_affine_range_sum.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/data_structure/point_set_range_composite.0.test.cpp
    title: test/data_structure/point_set_range_composite.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/data_structure/queue_operate_all_composite.0.test.cpp
    title: test/data_structure/queue_operate_all_composite.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/data_structure/range_affine_point_get.0.test.cpp
    title: test/data_structure/range_affine_point_get.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/data_structure/range_affine_range_sum.0.test.cpp
    title: test/data_structure/range_affine_range_sum.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/enumerative_combinatorics/bell_number.0.test.cpp
    title: test/enumerative_combinatorics/bell_number.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/enumerative_combinatorics/factorial.0.test.cpp
    title: test/enumerative_combinatorics/factorial.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/enumerative_combinatorics/partition_function.0.test.cpp
    title: test/enumerative_combinatorics/partition_function.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/enumerative_combinatorics/sharp_p_subset_sum.0.test.cpp
    title: test/enumerative_combinatorics/sharp_p_subset_sum.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/enumerative_combinatorics/stirling_number_of_the_first_kind.0.test.cpp
    title: test/enumerative_combinatorics/stirling_number_of_the_first_kind.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/enumerative_combinatorics/stirling_number_of_the_first_kind_fixed_k.0.test.cpp
    title: test/enumerative_combinatorics/stirling_number_of_the_first_kind_fixed_k.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/enumerative_combinatorics/stirling_number_of_the_second_kind.0.test.cpp
    title: test/enumerative_combinatorics/stirling_number_of_the_second_kind.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/enumerative_combinatorics/stirling_number_of_the_second_kind_fixed_k.0.test.cpp
    title: test/enumerative_combinatorics/stirling_number_of_the_second_kind_fixed_k.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/composition_of_formal_power_series_large.0.test.cpp
    title: test/formal_power_series/composition_of_formal_power_series_large.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/compositional_inverse_of_formal_power_series_large.0.test.cpp
    title: test/formal_power_series/compositional_inverse_of_formal_power_series_large.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/consecutive_terms_of_linear_recurrent_sequence.0.test.cpp
    title: test/formal_power_series/consecutive_terms_of_linear_recurrent_sequence.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/conversion_from_monomial_basis_to_newton_basis.0.test.cpp
    title: test/formal_power_series/conversion_from_monomial_basis_to_newton_basis.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/division_of_polynomials.0.test.cpp
    title: test/formal_power_series/division_of_polynomials.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/exp_of_formal_power_series.0.test.cpp
    title: test/formal_power_series/exp_of_formal_power_series.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/find_linear_recurrence.0.test.cpp
    title: test/formal_power_series/find_linear_recurrence.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/inv_of_formal_power_series.0.test.cpp
    title: test/formal_power_series/inv_of_formal_power_series.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/inv_of_formal_power_series.1.test.cpp
    title: test/formal_power_series/inv_of_formal_power_series.1.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/inv_of_polynomials.0.test.cpp
    title: test/formal_power_series/inv_of_polynomials.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/kth_term_of_linearly_recurrent_sequence.0.test.cpp
    title: test/formal_power_series/kth_term_of_linearly_recurrent_sequence.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/log_of_formal_power_series.0.test.cpp
    title: test/formal_power_series/log_of_formal_power_series.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/multipoint_evaluation.0.test.cpp
    title: test/formal_power_series/multipoint_evaluation.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/multipoint_evaluation_on_geometric_sequence.0.test.cpp
    title: test/formal_power_series/multipoint_evaluation_on_geometric_sequence.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/multivariate_power_series.0.test.cpp
    title: test/formal_power_series/multivariate_power_series.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/polynomial_interpolation.0.test.cpp
    title: test/formal_power_series/polynomial_interpolation.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/polynomial_interpolation_on_geometric_sequence.0.test.cpp
    title: test/formal_power_series/polynomial_interpolation_on_geometric_sequence.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/polynomial_taylor_shift.0.test.cpp
    title: test/formal_power_series/polynomial_taylor_shift.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/polynomial_taylor_shift.1.test.cpp
    title: test/formal_power_series/polynomial_taylor_shift.1.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/pow_of_formal_power_series.0.test.cpp
    title: test/formal_power_series/pow_of_formal_power_series.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/product_of_polynomial_sequence.0.test.cpp
    title: test/formal_power_series/product_of_polynomial_sequence.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/shift_of_sampling_points_of_polynomial.0.test.cpp
    title: test/formal_power_series/shift_of_sampling_points_of_polynomial.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/shift_of_sampling_points_of_polynomial.1.test.cpp
    title: test/formal_power_series/shift_of_sampling_points_of_polynomial.1.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/formal_power_series/sqrt_of_formal_power_series.0.test.cpp
    title: test/formal_power_series/sqrt_of_formal_power_series.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/matrix/adjugate_matrix.0.test.cpp
    title: test/matrix/adjugate_matrix.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/matrix/characteristic_polynomial.0.test.cpp
    title: test/matrix/characteristic_polynomial.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/matrix/characteristic_polynomial.1.test.cpp
    title: test/matrix/characteristic_polynomial.1.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/matrix/inverse_matrix.0.test.cpp
    title: test/matrix/inverse_matrix.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/matrix/matrix_det.0.test.cpp
    title: test/matrix/matrix_det.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/matrix/matrix_product.0.test.cpp
    title: test/matrix/matrix_product.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/matrix/pow_of_matrix.0.test.cpp
    title: test/matrix/pow_of_matrix.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/matrix/sparse_matrix_det.0.test.cpp
    title: test/matrix/sparse_matrix_det.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/set_power_series/exp_of_set_power_series.0.test.cpp
    title: test/set_power_series/exp_of_set_power_series.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/set_power_series/inv_of_set_power_series.0.test.cpp
    title: test/set_power_series/inv_of_set_power_series.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/set_power_series/log_of_set_power_series.0.test.cpp
    title: test/set_power_series/log_of_set_power_series.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/set_power_series/polynomial_composite_set_power_series.0.test.cpp
    title: test/set_power_series/polynomial_composite_set_power_series.0.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/set_power_series/subset_convolution.0.test.cpp
    title: test/set_power_series/subset_convolution.0.test.cpp
  _isVerificationFailed: false
  _pathExtension: hpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    links: []
  bundledCode: "#line 2 \"modint.hpp\"\n\n#include <iostream>\n#include <type_traits>\n\
    \n// clang-format off\ntemplate<unsigned Mod> class ModInt {\n    static_assert((Mod\
    \ >> 31) == 0, \"`Mod` must less than 2^(31)\");\n    template<typename Int>\n\
    \    static std::enable_if_t<std::is_integral_v<Int>, unsigned> safe_mod(Int v)\
    \ { using D = std::common_type_t<Int, unsigned>; return (v %= (int)Mod) < 0 ?\
    \ (D)(v + (int)Mod) : (D)v; }\n    struct PrivateConstructor {} static inline\
    \ private_constructor{};\n    ModInt(PrivateConstructor, unsigned v) : v_(v) {}\n\
    \    unsigned v_;\n\npublic:\n    static unsigned mod() { return Mod; }\n    static\
    \ ModInt from_raw(unsigned v) { return ModInt(private_constructor, v); }\n   \
    \ static ModInt zero() { return from_raw(0); }\n    static ModInt one() { return\
    \ from_raw(1); }\n    bool is_zero() const { return v_ == 0; }\n    bool is_one()\
    \ const { return v_ == 1; }\n    ModInt() : v_() {}\n    template<typename Int,\
    \ typename std::enable_if_t<std::is_signed_v<Int>, int> = 0> ModInt(Int v) : v_(safe_mod(v))\
    \ {}\n    template<typename Int, typename std::enable_if_t<std::is_unsigned_v<Int>,\
    \ int> = 0> ModInt(Int v) : v_(v % Mod) {}\n    unsigned val() const { return\
    \ v_; }\n    ModInt operator-() const { return from_raw(v_ == 0 ? v_ : Mod - v_);\
    \ }\n    ModInt pow(long long e) const { if (e < 0) return inv().pow(-e); for\
    \ (ModInt x(*this), res(from_raw(1));; x *= x) { if (e & 1) res *= x; if ((e >>=\
    \ 1) == 0) return res; }}\n    ModInt inv() const { int x1 = 1, x3 = 0, a = val(),\
    \ b = Mod; while (b) { const int q = a / b, x1_old = x1, a_old = a; x1 = x3, x3\
    \ = x1_old - x3 * q, a = b, b = a_old - b * q; } return from_raw(x1 < 0 ? x1 +\
    \ (int)Mod : x1); }\n    template<bool Odd = (Mod & 1)> std::enable_if_t<Odd,\
    \ ModInt> div_by_2() const { if (v_ & 1) return from_raw((v_ + Mod) >> 1); return\
    \ from_raw(v_ >> 1); }\n    ModInt &operator+=(const ModInt &a) { if ((v_ += a.v_)\
    \ >= Mod) v_ -= Mod; return *this; }\n    ModInt &operator-=(const ModInt &a)\
    \ { if ((v_ += Mod - a.v_) >= Mod) v_ -= Mod; return *this; }\n    ModInt &operator*=(const\
    \ ModInt &a) { v_ = (unsigned long long)v_ * a.v_ % Mod; return *this; }\n   \
    \ ModInt &operator/=(const ModInt &a) { return *this *= a.inv(); }\n    ModInt\
    \ &operator++() { return *this += one(); }\n    ModInt operator++(int) { ModInt\
    \ o(*this); *this += one(); return o; }\n    ModInt &operator--() { return *this\
    \ -= one(); }\n    ModInt operator--(int) { ModInt o(*this); *this -= one(); return\
    \ o; }\n    friend ModInt operator+(const ModInt &a, const ModInt &b) { return\
    \ ModInt(a) += b; }\n    friend ModInt operator-(const ModInt &a, const ModInt\
    \ &b) { return ModInt(a) -= b; }\n    friend ModInt operator*(const ModInt &a,\
    \ const ModInt &b) { return ModInt(a) *= b; }\n    friend ModInt operator/(const\
    \ ModInt &a, const ModInt &b) { return ModInt(a) /= b; }\n    friend bool operator==(const\
    \ ModInt &a, const ModInt &b) { return a.v_ == b.v_; }\n    friend bool operator!=(const\
    \ ModInt &a, const ModInt &b) { return a.v_ != b.v_; }\n    friend std::istream\
    \ &operator>>(std::istream &a, ModInt &b) { int v; a >> v; b.v_ = safe_mod(v);\
    \ return a; }\n    friend std::ostream &operator<<(std::ostream &a, const ModInt\
    \ &b) { return a << b.val(); }\n};\n// clang-format on\n"
  code: "#pragma once\n\n#include <iostream>\n#include <type_traits>\n\n// clang-format\
    \ off\ntemplate<unsigned Mod> class ModInt {\n    static_assert((Mod >> 31) ==\
    \ 0, \"`Mod` must less than 2^(31)\");\n    template<typename Int>\n    static\
    \ std::enable_if_t<std::is_integral_v<Int>, unsigned> safe_mod(Int v) { using\
    \ D = std::common_type_t<Int, unsigned>; return (v %= (int)Mod) < 0 ? (D)(v +\
    \ (int)Mod) : (D)v; }\n    struct PrivateConstructor {} static inline private_constructor{};\n\
    \    ModInt(PrivateConstructor, unsigned v) : v_(v) {}\n    unsigned v_;\n\npublic:\n\
    \    static unsigned mod() { return Mod; }\n    static ModInt from_raw(unsigned\
    \ v) { return ModInt(private_constructor, v); }\n    static ModInt zero() { return\
    \ from_raw(0); }\n    static ModInt one() { return from_raw(1); }\n    bool is_zero()\
    \ const { return v_ == 0; }\n    bool is_one() const { return v_ == 1; }\n   \
    \ ModInt() : v_() {}\n    template<typename Int, typename std::enable_if_t<std::is_signed_v<Int>,\
    \ int> = 0> ModInt(Int v) : v_(safe_mod(v)) {}\n    template<typename Int, typename\
    \ std::enable_if_t<std::is_unsigned_v<Int>, int> = 0> ModInt(Int v) : v_(v % Mod)\
    \ {}\n    unsigned val() const { return v_; }\n    ModInt operator-() const {\
    \ return from_raw(v_ == 0 ? v_ : Mod - v_); }\n    ModInt pow(long long e) const\
    \ { if (e < 0) return inv().pow(-e); for (ModInt x(*this), res(from_raw(1));;\
    \ x *= x) { if (e & 1) res *= x; if ((e >>= 1) == 0) return res; }}\n    ModInt\
    \ inv() const { int x1 = 1, x3 = 0, a = val(), b = Mod; while (b) { const int\
    \ q = a / b, x1_old = x1, a_old = a; x1 = x3, x3 = x1_old - x3 * q, a = b, b =\
    \ a_old - b * q; } return from_raw(x1 < 0 ? x1 + (int)Mod : x1); }\n    template<bool\
    \ Odd = (Mod & 1)> std::enable_if_t<Odd, ModInt> div_by_2() const { if (v_ & 1)\
    \ return from_raw((v_ + Mod) >> 1); return from_raw(v_ >> 1); }\n    ModInt &operator+=(const\
    \ ModInt &a) { if ((v_ += a.v_) >= Mod) v_ -= Mod; return *this; }\n    ModInt\
    \ &operator-=(const ModInt &a) { if ((v_ += Mod - a.v_) >= Mod) v_ -= Mod; return\
    \ *this; }\n    ModInt &operator*=(const ModInt &a) { v_ = (unsigned long long)v_\
    \ * a.v_ % Mod; return *this; }\n    ModInt &operator/=(const ModInt &a) { return\
    \ *this *= a.inv(); }\n    ModInt &operator++() { return *this += one(); }\n \
    \   ModInt operator++(int) { ModInt o(*this); *this += one(); return o; }\n  \
    \  ModInt &operator--() { return *this -= one(); }\n    ModInt operator--(int)\
    \ { ModInt o(*this); *this -= one(); return o; }\n    friend ModInt operator+(const\
    \ ModInt &a, const ModInt &b) { return ModInt(a) += b; }\n    friend ModInt operator-(const\
    \ ModInt &a, const ModInt &b) { return ModInt(a) -= b; }\n    friend ModInt operator*(const\
    \ ModInt &a, const ModInt &b) { return ModInt(a) *= b; }\n    friend ModInt operator/(const\
    \ ModInt &a, const ModInt &b) { return ModInt(a) /= b; }\n    friend bool operator==(const\
    \ ModInt &a, const ModInt &b) { return a.v_ == b.v_; }\n    friend bool operator!=(const\
    \ ModInt &a, const ModInt &b) { return a.v_ != b.v_; }\n    friend std::istream\
    \ &operator>>(std::istream &a, ModInt &b) { int v; a >> v; b.v_ = safe_mod(v);\
    \ return a; }\n    friend std::ostream &operator<<(std::ostream &a, const ModInt\
    \ &b) { return a << b.val(); }\n};\n// clang-format on\n"
  dependsOn: []
  isVerificationFile: false
  path: modint.hpp
  requiredBy: []
  timestamp: '2025-01-19 15:28:01+08:00'
  verificationStatus: LIBRARY_ALL_AC
  verifiedWith:
  - test/convolution/bitwise_and_convolution.0.test.cpp
  - test/convolution/convolution_mod.0.test.cpp
  - test/convolution/multidimensional_convolution.0.test.cpp
  - test/convolution/2d_convolution.0.test.cpp
  - test/convolution/bitwise_xor_convolution.0.test.cpp
  - test/matrix/sparse_matrix_det.0.test.cpp
  - test/matrix/pow_of_matrix.0.test.cpp
  - test/matrix/adjugate_matrix.0.test.cpp
  - test/matrix/matrix_product.0.test.cpp
  - test/matrix/characteristic_polynomial.0.test.cpp
  - test/matrix/inverse_matrix.0.test.cpp
  - test/matrix/matrix_det.0.test.cpp
  - test/matrix/characteristic_polynomial.1.test.cpp
  - test/enumerative_combinatorics/factorial.0.test.cpp
  - test/enumerative_combinatorics/sharp_p_subset_sum.0.test.cpp
  - test/enumerative_combinatorics/stirling_number_of_the_first_kind.0.test.cpp
  - test/enumerative_combinatorics/partition_function.0.test.cpp
  - test/enumerative_combinatorics/stirling_number_of_the_second_kind_fixed_k.0.test.cpp
  - test/enumerative_combinatorics/stirling_number_of_the_first_kind_fixed_k.0.test.cpp
  - test/enumerative_combinatorics/stirling_number_of_the_second_kind.0.test.cpp
  - test/enumerative_combinatorics/bell_number.0.test.cpp
  - test/set_power_series/log_of_set_power_series.0.test.cpp
  - test/set_power_series/inv_of_set_power_series.0.test.cpp
  - test/set_power_series/polynomial_composite_set_power_series.0.test.cpp
  - test/set_power_series/exp_of_set_power_series.0.test.cpp
  - test/set_power_series/subset_convolution.0.test.cpp
  - test/formal_power_series/polynomial_taylor_shift.0.test.cpp
  - test/formal_power_series/multivariate_power_series.0.test.cpp
  - test/formal_power_series/product_of_polynomial_sequence.0.test.cpp
  - test/formal_power_series/multipoint_evaluation.0.test.cpp
  - test/formal_power_series/exp_of_formal_power_series.0.test.cpp
  - test/formal_power_series/shift_of_sampling_points_of_polynomial.0.test.cpp
  - test/formal_power_series/find_linear_recurrence.0.test.cpp
  - test/formal_power_series/consecutive_terms_of_linear_recurrent_sequence.0.test.cpp
  - test/formal_power_series/sqrt_of_formal_power_series.0.test.cpp
  - test/formal_power_series/kth_term_of_linearly_recurrent_sequence.0.test.cpp
  - test/formal_power_series/conversion_from_monomial_basis_to_newton_basis.0.test.cpp
  - test/formal_power_series/composition_of_formal_power_series_large.0.test.cpp
  - test/formal_power_series/inv_of_formal_power_series.0.test.cpp
  - test/formal_power_series/shift_of_sampling_points_of_polynomial.1.test.cpp
  - test/formal_power_series/log_of_formal_power_series.0.test.cpp
  - test/formal_power_series/inv_of_polynomials.0.test.cpp
  - test/formal_power_series/pow_of_formal_power_series.0.test.cpp
  - test/formal_power_series/polynomial_interpolation.0.test.cpp
  - test/formal_power_series/division_of_polynomials.0.test.cpp
  - test/formal_power_series/inv_of_formal_power_series.1.test.cpp
  - test/formal_power_series/multipoint_evaluation_on_geometric_sequence.0.test.cpp
  - test/formal_power_series/polynomial_interpolation_on_geometric_sequence.0.test.cpp
  - test/formal_power_series/polynomial_taylor_shift.1.test.cpp
  - test/formal_power_series/compositional_inverse_of_formal_power_series_large.0.test.cpp
  - test/data_structure/range_affine_range_sum.0.test.cpp
  - test/data_structure/range_affine_point_get.0.test.cpp
  - test/data_structure/queue_operate_all_composite.0.test.cpp
  - test/data_structure/point_set_range_composite.0.test.cpp
  - test/data_structure/dynamic_sequence_range_affine_range_sum.0.test.cpp
documentation_of: modint.hpp
layout: document
redirect_from:
- /library/modint.hpp
- /library/modint.hpp.html
title: modint.hpp
---
